<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFP Benchmark Results</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .status { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px; }
        .error { background: #ffeeee; color: #cc0000; }
        .success { background: #eeffee; color: #006600; }
        .source-nfp { background-color: #e8f5e8; color: #2d7d2d; font-weight: bold; }
        .source-jdk { background-color: #f0f0f0; color: #666666; font-weight: bold; }
        .source-ptb { background-color: #e8f0ff; color: #1e5fa8; font-weight: bold; }
        .file-icon { cursor: pointer; font-size: 16px; color: #666; text-align: center; }
        .file-icon:hover { color: #333; }
        .json-popup {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; border: 2px solid #ccc; border-radius: 8px;
            padding: 20px; max-width: 80%; max-height: 80%; overflow: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000;
        }
        .json-content {
            font-family: monospace; white-space: pre-wrap;
            background: #f8f8f8; padding: 15px; border-radius: 4px;
            border: 1px solid #ddd; max-height: 400px; overflow: auto;
        }
        .close-btn {
            float: right; cursor: pointer; font-size: 20px;
            background: #f44336; color: white; border: none;
            border-radius: 4px; padding: 5px 10px; margin-bottom: 10px;
        }
        .popup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 999;
        }
        .search-container {
            display: flex; align-items: center; margin: 20px 0;
            max-width: 600px; position: relative;
        }
        .search-input {
            flex: 1; padding: 10px 40px 10px 10px; border: 2px solid #ddd;
            border-radius: 4px; font-size: 14px;
        }
        .search-icon {
            position: absolute; right: 12px; color: #666;
            pointer-events: none; font-size: 16px;
        }
        .dropdown {
            position: absolute; top: 100%; left: 0; right: 0;
            background: white; border: 1px solid #ddd; border-top: none;
            max-height: 200px; overflow-y: auto; z-index: 100;
            display: none;
        }
        .dropdown-item {
            padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;
        }
        .dropdown-item:hover {
            background: #f5f5f5;
        }
        .status-bottom {
            margin-top: 20px; padding: 10px; background: #f0f0f0;
            border-radius: 4px; font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>NFP Benchmark Results</h1>

    <div class="search-container">
        <input type="text" id="file-search" class="search-input" placeholder="Search result files...">
        <span class="search-icon">üîç</span>
        <div id="search-dropdown" class="dropdown"></div>
    </div>

    <div id="test-results-container">
        <!-- Dynamic test result blocks will be inserted here -->
    </div>

    <!-- Old table removed - now using focused test result blocks -->

    <div id="status-bottom" class="status-bottom" style="display: none;"></div>

    <script src="dataProcessor.js"></script>
    <script src="apiClient.js"></script>
    <script>
        let currentFilename = '';
        let searchTimeout = null;

        async function loadInitialResults() {
            try {
                // Load JMH results and sizes in parallel
                const [jmhResponse, sizesResponse] = await Promise.all([
                    fetch('/api/jmh-results'),
                    fetch('/api/sizes')
                ]);

                if (!jmhResponse.ok) {
                    throw new Error(`JMH endpoint error: ${jmhResponse.status}`);
                }
                if (!sizesResponse.ok) {
                    throw new Error(`Sizes endpoint error: ${sizesResponse.status}`);
                }

                const jmhData = await jmhResponse.json();
                const sizesData = await sizesResponse.json();

                // Validate data before processing
                if (!jmhData.data || !Array.isArray(jmhData.data) || jmhData.data.length === 0) {
                    console.error('Invalid or empty JMH data:', jmhData);
                    throw new Error(`File "${jmhData.filename}" appears corrupt or empty - no valid benchmark data found`);
                }

                // Process data using new architecture
                const parsedJMH = parseJMHResults(jmhData.data);
                const combinedData = combineResultsWithSizes(parsedJMH, sizesData.data);
                const sizeSummary = calculateSizeSummary(sizesData.data);

                currentFilename = jmhData.filename;
                document.getElementById('file-search').value = currentFilename;

                renderTestResultBlocks(combinedData, sizesData.data, currentFilename);
                updateBottomStatus(combinedData.length, currentFilename);

            } catch (error) {
                console.error('Error loading results:', error);
                // Show error in bottom status with clear message
                const statusBottom = document.getElementById('status-bottom');
                statusBottom.innerHTML = `<span style="color: #cc0000; font-weight: bold;">‚ö† Error loading results: ${error.message}</span>`;
                statusBottom.style.display = 'block';

                // Clear the test results container to avoid showing stale data
                document.getElementById('test-results-container').innerHTML = '';
            }
        }

        async function loadFileByName(filename) {
            try {
                // Load specific JMH file and current sizes
                const [jmhResponse, sizesResponse] = await Promise.all([
                    fetch(`/api/jmh-file?name=${encodeURIComponent(filename)}`),
                    fetch('/api/sizes')
                ]);

                if (!jmhResponse.ok) {
                    throw new Error(`JMH file error: ${jmhResponse.status}`);
                }
                if (!sizesResponse.ok) {
                    throw new Error(`Sizes error: ${sizesResponse.status}`);
                }

                const jmhData = await jmhResponse.json();
                const sizesData = await sizesResponse.json();

                // Validate data before processing
                if (!jmhData.data || !Array.isArray(jmhData.data) || jmhData.data.length === 0) {
                    console.error('Invalid or empty JMH data for file:', filename, jmhData);
                    throw new Error(`File "${filename}" appears corrupt or empty - no valid benchmark data found. File may be truncated or incomplete.`);
                }

                // Process data using new architecture
                const parsedJMH = parseJMHResults(jmhData.data);
                const combinedData = combineResultsWithSizes(parsedJMH, sizesData.data);
                const sizeSummary = calculateSizeSummary(sizesData.data);

                currentFilename = jmhData.filename;
                document.getElementById('file-search').value = currentFilename;
                hideDropdown();

                renderTestResultBlocks(combinedData, sizesData.data, currentFilename);
                updateBottomStatus(combinedData.length, currentFilename);

            } catch (error) {
                console.error('Error loading file:', error);
                // Show error in bottom status with clear message
                const statusBottom = document.getElementById('status-bottom');
                statusBottom.innerHTML = `<span style="color: #cc0000; font-weight: bold;">‚ö† Error loading file: ${error.message}</span>`;
                statusBottom.style.display = 'block';

                // Clear the test results container to avoid showing stale data
                document.getElementById('test-results-container').innerHTML = '';
            }
        }

        async function searchFiles(query) {
            try {
                const url = query ? `/api/search?type=jmh&q=${encodeURIComponent(query)}` : '/api/search?type=jmh';
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            } catch (error) {
                console.error('Search error:', error);
                return [];
            }
        }

        function showDropdown(files) {
            const dropdown = document.getElementById('search-dropdown');
            dropdown.innerHTML = '';

            if (files.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            files.forEach(filename => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = filename;
                item.onclick = () => loadFileByName(filename);
                dropdown.appendChild(item);
            });

            dropdown.style.display = 'block';
        }

        function hideDropdown() {
            document.getElementById('search-dropdown').style.display = 'none';
        }

        function renderTestResultBlocks(combinedData, sizesData, filename) {
            const container = document.getElementById('test-results-container');

            if (Object.keys(sizesData).length === 0) {
                container.innerHTML = '<div style="background: #f8f8f8; color: #666; padding: 8px 12px; border-radius: 12px; font-style: italic; margin: 20px 0;">No size data available - add sizes.json file to see compression ratios</div>';
                return;
            }

            // Group data by test type
            const groupedData = groupDataByTestAndSource(combinedData);

            let html = '';

            // Create a block for each test type that has size data
            Object.keys(sizesData).forEach(testType => {
                const sizeData = sizesData[testType];
                const testResults = groupedData[testType] || {};

                html += '<div class="test-result-block" style="margin-bottom: 30px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">';

                // Focused panel header
                html += '<div class="test-panel" style="background: #f8f8f8; padding: 10px 15px; border-bottom: 1px solid #ddd;">';
                html += `<div style="display: flex; align-items: center; gap: 15px;">`;
                html += `<span style="font-weight: bold;">${testType}</span>`;
                // Store test data in data attributes to avoid escaping issues
                const testDataEscaped = (sizeData.testData || '').replace(/"/g, '&quot;');
                html += `<span class="test-type" style="color: #0066cc; cursor: pointer; text-decoration: underline;" data-test-type="${testType}" data-data-type="${sizeData.dataType}" data-test-data="${testDataEscaped}">${sizeData.dataType}</span>`;

                // Focused size bubbles
                html += '<div style="display: flex; gap: 10px; margin-left: auto;">';

                // JDK bubble
                if (sizeData.JDK) {
                    const jdkSize = formatSize(sizeData.JDK);
                    html += `<div style="background: #f0f0f0; color: #666; padding: 4px 8px; border-radius: 8px; font-size: 12px; font-weight: bold;">( JDK ) ${jdkSize} 1x</div>`;
                }

                // NFP bubble
                if (sizeData.NFP) {
                    const nfpSize = formatSize(sizeData.NFP);
                    const ratio = sizeData.JDK ? (sizeData.NFP / sizeData.JDK).toFixed(1) : '1';
                    html += `<div style="background: #e8f5e8; color: #2d7d2d; padding: 4px 8px; border-radius: 8px; font-size: 12px; font-weight: bold;">( NFP ) ${nfpSize} ${ratio}x</div>`;
                }

                html += '</div></div></div>';

                // Results table for this test type
                html += '<div class="test-results">';
                if (Object.keys(testResults).length > 0) {
                    html += '<table style="width: 100%; border-collapse: collapse;">';
                    html += '<thead><tr style="background: #f2f2f2;"><th style="padding: 8px; text-align: left;">Source</th><th style="padding: 8px; text-align: left;">Score (ops/s)</th><th style="padding: 8px; text-align: left;">Size (bytes)</th><th style="padding: 8px; text-align: left;">Benchmark</th></tr></thead>';
                    html += '<tbody>';

                    Object.keys(testResults).forEach(src => {
                        const results = testResults[src];
                        results.forEach(result => {
                            html += '<tr>';
                            html += `<td style="padding: 8px; background-color: ${getSourceColor(src)}; font-weight: bold;">${src}</td>`;
                            html += `<td style="padding: 8px;">${Math.round(result.score).toLocaleString()}</td>`;
                            html += `<td style="padding: 8px;">${result.size >= 0 ? result.size : 'N/A'}</td>`;
                            html += `<td style="padding: 8px; font-size: 11px;">${result.benchmark}</td>`;
                            html += '</tr>';
                        });
                    });

                    html += '</tbody></table>';
                } else {
                    html += '<p style="padding: 15px; margin: 0; color: #666; font-style: italic;">No throughput results for this test type</p>';
                }
                html += '</div>';

                html += '</div>'; // Close test-result-block
            });

            container.innerHTML = html;
        }

        function getSourceColor(src) {
            switch(src.toLowerCase()) {
                case 'nfp': return '#e8f5e8';
                case 'jdk': return '#f0f0f0';
                case 'ptb': return '#e8f0ff';
                default: return '#f8f8f8';
            }
        }

        function showTestDataPopup(testType, dataType, testData) {
            // Remove existing popup if any
            const existingPopup = document.querySelector('.popup-overlay');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            overlay.onclick = closeTestDataPopup;

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'json-popup';

            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.textContent = '‚úï';
            closeBtn.onclick = closeTestDataPopup;

            // Test data content
            const content = document.createElement('div');
            content.className = 'json-content';
            content.textContent = testData.replace(/\\n/g, '\n');

            // Title
            const title = document.createElement('h3');
            title.textContent = `Test Data - ${testType} (${dataType})`;
            title.style.marginTop = '0';

            popup.appendChild(closeBtn);
            popup.appendChild(title);
            popup.appendChild(content);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        function closeTestDataPopup() {
            const popup = document.querySelector('.popup-overlay');
            if (popup) {
                popup.remove();
            }
        }

        function formatSize(bytes) {
            if (bytes >= 1000) {
                return (bytes / 1000).toPrecision(3) + 'k';
            }
            return bytes.toString();
        }

        function updateBottomStatus(count, filename) {
            const statusBottom = document.getElementById('status-bottom');
            statusBottom.innerHTML = `Showing ${count} benchmark results from file: <strong>${filename}</strong>`;
            statusBottom.style.display = 'block';
        }

        // Old renderTable function removed - now using renderTestResultBlocks

        function showJsonPopup(item, index) {
            // Remove existing popup if any
            const existingPopup = document.querySelector('.popup-overlay');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            overlay.onclick = closeJsonPopup;

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'json-popup';

            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.textContent = '‚úï';
            closeBtn.onclick = closeJsonPopup;

            // JSON content
            const jsonContent = document.createElement('div');
            jsonContent.className = 'json-content';
            jsonContent.textContent = JSON.stringify(item, null, 2);

            // Title
            const title = document.createElement('h3');
            title.textContent = `Raw JSON Data - Row ${index + 1}`;
            title.style.marginTop = '0';

            popup.appendChild(closeBtn);
            popup.appendChild(title);
            popup.appendChild(jsonContent);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        function closeJsonPopup() {
            const popup = document.querySelector('.popup-overlay');
            if (popup) {
                popup.remove();
            }
        }

        // Set up search functionality
        document.getElementById('file-search').addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            // Search after 300ms delay
            searchTimeout = setTimeout(async () => {
                if (query !== currentFilename) {
                    const files = await searchFiles(query);
                    showDropdown(files);
                }
            }, 300);
        });

        document.getElementById('file-search').addEventListener('focus', async (e) => {
            // Clear the input when focused so user can type new search
            e.target.select();

            const query = e.target.value;
            if (query !== currentFilename) {
                const files = await searchFiles(query);
                showDropdown(files);
            }
        });

        document.getElementById('file-search').addEventListener('blur', () => {
            // Hide dropdown after a short delay to allow clicks
            setTimeout(hideDropdown, 200);
        });

        // Click outside to hide dropdown
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                hideDropdown();
            }
        });

        // Set up click handlers for test type links
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('test-type')) {
                const testType = e.target.getAttribute('data-test-type');
                const dataType = e.target.getAttribute('data-data-type');
                const testData = e.target.getAttribute('data-test-data');
                if (testData) {
                    // Unescape the test data
                    const unescapedData = testData.replace(/&quot;/g, '"');
                    showTestDataPopup(testType, dataType, unescapedData);
                }
            }
        });

        // Load initial results when page loads
        loadInitialResults();
    </script>
</body>
</html>
