package io.github.simbo1905.no.framework;

import org.junit.jupiter.api.Test;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

/// Tests for enum signature verification and ordinal-based serialization
public class EnumSignatureTest {

    public enum Color {
        RED, GREEN, BLUE
    }

    public enum Size {
        SMALL, MEDIUM, LARGE, EXTRA_LARGE
    }

    public record EnumHolder(Color color, Size size) {}
    public record EnumArrayHolder(Color[] colors, Size[] sizes) {}

    @Test
    void testEnumSignatureComputedInDisabledMode() throws IOException {
        // Given
        Pickler<Color> pickler = Pickler.forClass(Color.class, EnumSignatureMode.DISABLED);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        
        // When - serialize
        pickler.write(baos, Color.GREEN);
        byte[] data = baos.toByteArray();
        
        // Then - should write signature + ordinal
        // Expected: signature (8 bytes hash) + ordinal (1 byte for small enum)
        assertThat(data.length).isGreaterThan(8); // At least signature + ordinal
        
        // When - deserialize with same pickler (same signature)
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        Color deserialized = pickler.read(bais);
        
        // Then
        assertThat(deserialized).isEqualTo(Color.GREEN);
    }

    @Test
    void testEnumSignatureBypassedInDefaultedMode() throws IOException {
        // Given
        Pickler<Color> pickler = Pickler.forClass(Color.class, EnumSignatureMode.DEFAULTED);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        
        // When - serialize
        pickler.write(baos, Color.BLUE);
        byte[] data = baos.toByteArray();
        
        // Then - should write only ordinal (no signature)
        // Expected: just ordinal (1 byte for small enum)
        assertThat(data.length).isEqualTo(1);
        assertThat(data[0]).isEqualTo((byte)2); // BLUE is ordinal 2
        
        // When - deserialize
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        Color deserialized = pickler.read(bais);
        
        // Then
        assertThat(deserialized).isEqualTo(Color.BLUE);
    }

    @Test
    void testEnumSerializedUsingOrdinals() throws IOException {
        // Given
        Pickler<Size> pickler = Pickler.forClass(Size.class, EnumSignatureMode.DEFAULTED);
        
        // When/Then - test each enum value serializes to its ordinal
        assertSerializesToOrdinal(pickler, Size.SMALL, 0);
        assertSerializesToOrdinal(pickler, Size.MEDIUM, 1);
        assertSerializesToOrdinal(pickler, Size.LARGE, 2);
        assertSerializesToOrdinal(pickler, Size.EXTRA_LARGE, 3);
    }

    @Test
    void testEnumArraysUseOrdinals() throws IOException {
        // Given
        Color[] colors = {Color.RED, Color.GREEN, Color.BLUE, Color.RED};
        Pickler<Color[]> pickler = Pickler.forClass(Color[].class, EnumSignatureMode.DEFAULTED);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        
        // When
        pickler.write(baos, colors);
        byte[] data = baos.toByteArray();
        
        // Then - should contain array length + ordinals
        // Expected format: length (varint) + ordinals
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        Color[] deserialized = pickler.read(bais);
        
        assertArrayEquals(colors, deserialized);
    }

    @Test
    void testSignatureComputedFromClassNameAndConstants() throws IOException {
        // This test verifies the signature is computed correctly
        // Signature should be hash of: "io.github.simbo1905.no.framework.EnumSignatureTest$Color!RED!GREEN!BLUE"
        
        // Given - two different enums with same ordinals but different signatures
        Pickler<Color> colorPickler = Pickler.forClass(Color.class, EnumSignatureMode.DISABLED);
        Pickler<Size> sizePickler = Pickler.forClass(Size.class, EnumSignatureMode.DISABLED);
        
        // When - serialize same ordinal from different enums
        ByteArrayOutputStream colorBaos = new ByteArrayOutputStream();
        colorPickler.write(colorBaos, Color.RED); // ordinal 0
        
        ByteArrayOutputStream sizeBaos = new ByteArrayOutputStream();
        sizePickler.write(sizeBaos, Size.SMALL); // ordinal 0
        
        // Then - signatures should be different (first 8 bytes)
        byte[] colorData = colorBaos.toByteArray();
        byte[] sizeData = sizeBaos.toByteArray();
        
        assertThat(colorData.length).isGreaterThan(8);
        assertThat(sizeData.length).isGreaterThan(8);
        
        // Extract signatures (first 8 bytes)
        byte[] colorSignature = new byte[8];
        byte[] sizeSignature = new byte[8];
        System.arraycopy(colorData, 0, colorSignature, 0, 8);
        System.arraycopy(sizeData, 0, sizeSignature, 0, 8);
        
        assertThat(colorSignature).isNotEqualTo(sizeSignature);
    }

    @Test
    void testSignatureMismatchThrowsException() throws IOException {
        // Given - serialize with one enum
        Pickler<Color> colorPickler = Pickler.forClass(Color.class, EnumSignatureMode.DISABLED);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        colorPickler.write(baos, Color.GREEN);
        byte[] data = baos.toByteArray();
        
        // When/Then - try to deserialize with different enum (different signature)
        Pickler<Size> sizePickler = Pickler.forClass(Size.class, EnumSignatureMode.DISABLED);
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        
        assertThatThrownBy(() -> sizePickler.read(bais))
            .isInstanceOf(IOException.class)
            .hasMessageContaining("signature");
    }

    @Test
    void testNestedEnumsInRecord() throws IOException {
        // Given
        EnumHolder holder = new EnumHolder(Color.BLUE, Size.LARGE);
        Pickler<EnumHolder> pickler = Pickler.forClass(EnumHolder.class, EnumSignatureMode.DEFAULTED);
        
        // When
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        pickler.write(baos, holder);
        
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        EnumHolder deserialized = pickler.read(bais);
        
        // Then
        assertThat(deserialized.color()).isEqualTo(Color.BLUE);
        assertThat(deserialized.size()).isEqualTo(Size.LARGE);
    }

    @Test
    void testEnumArraysInRecord() throws IOException {
        // Given
        Color[] colors = {Color.GREEN, Color.RED};
        Size[] sizes = {Size.EXTRA_LARGE, Size.SMALL, Size.MEDIUM};
        EnumArrayHolder holder = new EnumArrayHolder(colors, sizes);
        Pickler<EnumArrayHolder> pickler = Pickler.forClass(EnumArrayHolder.class, EnumSignatureMode.DEFAULTED);
        
        // When
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        pickler.write(baos, holder);
        
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        EnumArrayHolder deserialized = pickler.read(bais);
        
        // Then
        assertArrayEquals(colors, deserialized.colors());
        assertArrayEquals(sizes, deserialized.sizes());
    }

    private void assertSerializesToOrdinal(Pickler<Size> pickler, Size value, int expectedOrdinal) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        pickler.write(baos, value);
        byte[] data = baos.toByteArray();
        assertThat(data.length).isEqualTo(1);
        assertThat(data[0]).isEqualTo((byte)expectedOrdinal);
    }
}